//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from "rxjs/operators";
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
  scheduled,
  asyncScheduler,
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from "@angular/common/http";

import moment from "moment";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isTenantAvailable(
    body: IsTenantAvailableInput | undefined
  ): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsTenantAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsTenantAvailable(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<IsTenantAvailableOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<IsTenantAvailableOutput>;
        })
      );
  }

  protected processIsTenantAvailable(
    response: HttpResponseBase
  ): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IsTenantAvailableOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IsTenantAvailableOutput>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: RegisterInput | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/Register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RegisterOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RegisterOutput>;
        })
      );
  }

  protected processRegister(
    response: HttpResponseBase
  ): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RegisterOutput>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordInputDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePassword(body: UpdatePasswordInputDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Account/UpdatePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdatePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdatePassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdatePassword(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }
}

@Injectable()
export class AuditLogServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param keyword (optional)
   * @param exceptionOnly (optional)
   * @param tenantId (optional)
   * @param userId (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    exceptionOnly: boolean | undefined,
    tenantId: number | undefined,
    userId: number | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedAuditLogResultResponseDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (exceptionOnly === null)
      throw new Error("The parameter 'exceptionOnly' cannot be null.");
    else if (exceptionOnly !== undefined)
      url_ += "ExceptionOnly=" + encodeURIComponent("" + exceptionOnly) + "&";
    if (tenantId === null)
      throw new Error("The parameter 'tenantId' cannot be null.");
    else if (tenantId !== undefined)
      url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
    if (userId === null)
      throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined)
      url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PagedAuditLogResultResponseDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PagedAuditLogResultResponseDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<PagedAuditLogResultResponseDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 =
            PagedAuditLogResultResponseDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PagedAuditLogResultResponseDtoPagedResultDto>(
      null as any
    );
  }
}

@Injectable()
export class BrandServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateBrandDto | undefined): Observable<BrandDto> {
    let url_ = this.baseUrl + "/api/services/app/Brand/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BrandDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BrandDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<BrandDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Brand/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: BrandDto | undefined): Observable<BrandDto> {
    let url_ = this.baseUrl + "/api/services/app/Brand/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BrandDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BrandDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<BrandDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandDto>(null as any);
  }

  /**
   * @return Success
   */
  getAllList(): Observable<BrandDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Brand/GetAllList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllList(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<BrandDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandDtoListResultDto>;
        })
      );
  }

  protected processGetAllList(
    response: HttpResponseBase
  ): Observable<BrandDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandDtoListResultDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BrandDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Brand/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<BrandDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BrandDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandDtoPagedResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BrandDto> {
    let url_ = this.baseUrl + "/api/services/app/Brand/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BrandDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BrandDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BrandDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandDto>(null as any);
  }
}

@Injectable()
export class BrandingServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateBrandingDto | undefined): Observable<BrandingDto> {
    let url_ = this.baseUrl + "/api/services/app/Branding/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BrandingDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandingDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<BrandingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandingDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Branding/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: BrandingDto | undefined): Observable<BrandingDto> {
    let url_ = this.baseUrl + "/api/services/app/Branding/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BrandingDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandingDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<BrandingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandingDto>(null as any);
  }

  /**
   * @return Success
   */
  getAllList(): Observable<BrandingDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Branding/GetAllList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllList(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<BrandingDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandingDtoListResultDto>;
        })
      );
  }

  protected processGetAllList(
    response: HttpResponseBase
  ): Observable<BrandingDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandingDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandingDtoListResultDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BrandingDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Branding/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<BrandingDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandingDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BrandingDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandingDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandingDtoPagedResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BrandingDto> {
    let url_ = this.baseUrl + "/api/services/app/Branding/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BrandingDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BrandingDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BrandingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BrandingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BrandingDto>(null as any);
  }
}

@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeUiTheme(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeUiTheme(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }
}

@Injectable()
export class EditionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateEditionDto | undefined): Observable<EditionDto> {
    let url_ = this.baseUrl + "/api/services/app/Edition/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<EditionDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<EditionDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<EditionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EditionDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Edition/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EditionDto | undefined): Observable<EditionDto> {
    let url_ = this.baseUrl + "/api/services/app/Edition/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<EditionDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<EditionDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<EditionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EditionDto>(null as any);
  }

  /**
   * @return Success
   */
  getAllList(): Observable<EditionDto[]> {
    let url_ = this.baseUrl + "/api/services/app/Edition/GetAllList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllList(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<EditionDto[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              EditionDto[]
            >;
        })
      );
  }

  protected processGetAllList(
    response: HttpResponseBase
  ): Observable<EditionDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(EditionDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return scheduled([<EditionDto[]>(null as any)], asyncScheduler);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setFeatures(body: SetFeatureDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Edition/SetFeatures";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetFeatures(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetFeatures(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSetFeatures(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  getFeatures(editionId: number): Observable<NameValue[]> {
    let url_ = this.baseUrl + "/api/services/app/Edition/GetFeatures?";
    if (editionId === undefined || editionId === null)
      throw new Error(
        "The parameter 'editionId' must be defined and cannot be null."
      );
    else url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFeatures(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFeatures(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NameValue[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              NameValue[]
            >;
        })
      );
  }

  protected processGetFeatures(
    response: HttpResponseBase
  ): Observable<NameValue[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(NameValue.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return scheduled([<NameValue[]>(null as any)], asyncScheduler);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EditionDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Edition/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<EditionDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<EditionDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<EditionDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditionDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EditionDtoPagedResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EditionDto> {
    let url_ = this.baseUrl + "/api/services/app/Edition/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<EditionDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<EditionDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EditionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EditionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EditionDto>(null as any);
  }
}

@Injectable()
export class FileUploaderServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param file (optional)
   * @return Success
   */
  uploadImage(
    file: FileParameter | undefined
  ): Observable<UploadImageOutputModel> {
    let url_ = this.baseUrl + "/api/FileUploader/UploadImage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.");
    else
      content_.append(
        "File",
        file.data,
        file.fileName ? file.fileName : "File"
      );

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadImage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<UploadImageOutputModel>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<UploadImageOutputModel>;
        })
      );
  }

  protected processUploadImage(
    response: HttpResponseBase
  ): Observable<UploadImageOutputModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UploadImageOutputModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UploadImageOutputModel>(null as any);
  }
}

@Injectable()
export class RequestServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRequestDto | undefined): Observable<RequestDto> {
    let url_ = this.baseUrl + "/api/services/app/Request/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RequestDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RequestDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RequestDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RequestDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RequestDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Request/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RequestDto | undefined): Observable<RequestDto> {
    let url_ = this.baseUrl + "/api/services/app/Request/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RequestDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RequestDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RequestDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RequestDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RequestDto>(null as any);
  }

  /**
   * @return Success
   */
  getAllList(): Observable<RequestDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Request/GetAllList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllList(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RequestDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RequestDtoListResultDto>;
        })
      );
  }

  protected processGetAllList(
    response: HttpResponseBase
  ): Observable<RequestDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RequestDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RequestDtoListResultDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RequestDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Request/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RequestDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RequestDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RequestDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RequestDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RequestDtoPagedResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RequestDto> {
    let url_ = this.baseUrl + "/api/services/app/Request/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RequestDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RequestDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RequestDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RequestDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RequestDto>(null as any);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoleDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoleDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(null as any);
  }

  /**
   * @param permission (optional)
   * @return Success
   */
  getRoles(
    permission: string | undefined
  ): Observable<RoleListDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
    if (permission === null)
      throw new Error("The parameter 'permission' cannot be null.");
    else if (permission !== undefined)
      url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoleListDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoleListDtoListResultDto>;
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleListDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleListDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleListDtoListResultDto>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoleDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoleDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<PermissionDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PermissionDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PermissionDtoListResultDto>;
        })
      );
  }

  protected processGetAllPermissions(
    response: HttpResponseBase
  ): Observable<PermissionDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PermissionDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PermissionDtoListResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleForEdit(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<GetRoleForEditOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GetRoleForEditOutput>;
        })
      );
  }

  protected processGetRoleForEdit(
    response: HttpResponseBase
  ): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoleForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetRoleForEditOutput>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setPermissions(body: SetPermissionsInputDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Role/SetPermissions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSetPermissions(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  getPermissions(
    roleId: number
  ): Observable<GetPermissionsOutputDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetPermissions?";
    if (roleId === undefined || roleId === null)
      throw new Error(
        "The parameter 'roleId' must be defined and cannot be null."
      );
    else url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<GetPermissionsOutputDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GetPermissionsOutputDtoListResultDto>;
        })
      );
  }

  protected processGetPermissions(
    response: HttpResponseBase
  ): Observable<GetPermissionsOutputDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 =
            GetPermissionsOutputDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetPermissionsOutputDtoListResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoleDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoleDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RoleDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoleDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoleDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RoleDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDtoPagedResultDto>(null as any);
  }
}

@Injectable()
export class RoomServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRoomDto | undefined): Observable<RoomDto> {
    let url_ = this.baseUrl + "/api/services/app/Room/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoomDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoomDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RoomDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoomDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoomDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Room/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RoomDto | undefined): Observable<RoomDto> {
    let url_ = this.baseUrl + "/api/services/app/Room/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoomDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoomDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoomDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoomDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoomDto>(null as any);
  }

  /**
   * @return Success
   */
  getAllList(): Observable<RoomDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Room/GetAllList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllList(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoomDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoomDtoListResultDto>;
        })
      );
  }

  protected processGetAllList(
    response: HttpResponseBase
  ): Observable<RoomDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoomDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoomDtoListResultDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RoomDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Room/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoomDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoomDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RoomDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoomDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoomDtoPagedResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RoomDto> {
    let url_ = this.baseUrl + "/api/services/app/Room/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoomDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoomDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RoomDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoomDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoomDto>(null as any);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ =
      this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentLoginInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentLoginInformations(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<GetCurrentLoginInformationsOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GetCurrentLoginInformationsOutput>;
        })
      );
  }

  protected processGetCurrentLoginInformations(
    response: HttpResponseBase
  ): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateTenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenantDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getTenants(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PagedTenantResultDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTenants(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTenants(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PagedTenantResultDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PagedTenantResultDtoPagedResultDto>;
        })
      );
  }

  protected processGetTenants(
    response: HttpResponseBase
  ): Observable<PagedTenantResultDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PagedTenantResultDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PagedTenantResultDtoPagedResultDto>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setFeature(body: SetTenantFeatureDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/SetFeature";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetFeature(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetFeature(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSetFeature(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  getFeatures(tenantId: number): Observable<NameValue[]> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetFeatures?";
    if (tenantId === undefined || tenantId === null)
      throw new Error(
        "The parameter 'tenantId' must be defined and cannot be null."
      );
    else url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFeatures(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFeatures(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NameValue[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              NameValue[]
            >;
        })
      );
  }

  protected processGetFeatures(
    response: HttpResponseBase
  ): Observable<NameValue[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(NameValue.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return scheduled([<NameValue[]>(null as any)], asyncScheduler);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenantDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<TenantDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<TenantDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TenantDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<TenantDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDtoPagedResultDto>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: TenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenantDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(null as any);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  authenticate(
    body: AuthenticateModel | undefined
  ): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthenticate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<AuthenticateResultModel>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<AuthenticateResultModel>;
        })
      );
  }

  protected processAuthenticate(
    response: HttpResponseBase
  ): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AuthenticateResultModel>(null as any);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<
    ExternalLoginProviderInfoModel[]
  > {
    let url_ =
      this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExternalAuthenticationProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExternalAuthenticationProviders(
                response_ as any
              );
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ExternalLoginProviderInfoModel[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ExternalLoginProviderInfoModel[]
            >;
        })
      );
  }

  protected processGetExternalAuthenticationProviders(
    response: HttpResponseBase
  ): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(ExternalLoginProviderInfoModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return scheduled(
      [<ExternalLoginProviderInfoModel[]>(null as any)],
      asyncScheduler
    );
  }

  /**
   * @param body (optional)
   * @return Success
   */
  externalAuthenticate(
    body: ExternalAuthenticateModel | undefined
  ): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalAuthenticate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ExternalAuthenticateResultModel>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ExternalAuthenticateResultModel>;
        })
      );
  }

  protected processExternalAuthenticate(
    response: HttpResponseBase
  ): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExternalAuthenticateResultModel>(null as any);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateUserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  activate(body: Int64EntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Activate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  deActivate(body: Int64EntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  getRoles(): Observable<RoleDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoleDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoleDtoListResultDto>;
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDtoListResultDto>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeLanguage(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processChangePassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processResetPassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setPermissions(
    body: SetUserPermissionsInputDto | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/SetPermissions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSetPermissions(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param multiTenancySide (optional)
   * @return Success
   */
  getAllPermissions(
    multiTenancySide: MultiTenancySides | undefined
  ): Observable<UserPermissionDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAllPermissions?";
    if (multiTenancySide === null)
      throw new Error("The parameter 'multiTenancySide' cannot be null.");
    else if (multiTenancySide !== undefined)
      url_ +=
        "MultiTenancySide=" + encodeURIComponent("" + multiTenancySide) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<UserPermissionDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<UserPermissionDtoListResultDto>;
        })
      );
  }

  protected processGetAllPermissions(
    response: HttpResponseBase
  ): Observable<UserPermissionDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserPermissionDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserPermissionDtoListResultDto>(null as any);
  }

  /**
   * @param tenantId (optional)
   * @return Success
   */
  getPermissions(
    tenantId: number | undefined,
    userId: string
  ): Observable<GetUserPermissionsOutputDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetPermissions?";
    if (tenantId === null)
      throw new Error("The parameter 'tenantId' cannot be null.");
    else if (tenantId !== undefined)
      url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
    if (userId === undefined || userId === null)
      throw new Error(
        "The parameter 'userId' must be defined and cannot be null."
      );
    else url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<GetUserPermissionsOutputDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GetUserPermissionsOutputDtoListResultDto>;
        })
      );
  }

  protected processGetPermissions(
    response: HttpResponseBase
  ): Observable<GetUserPermissionsOutputDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 =
            GetUserPermissionsOutputDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetUserPermissionsOutputDtoListResultDto>(null as any);
  }

  /**
   * @return Success
   */
  getAllList(): Observable<UserDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAllList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllList(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<UserDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<UserDtoListResultDto>;
        })
      );
  }

  protected processGetAllList(
    response: HttpResponseBase
  ): Observable<UserDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDtoListResultDto>(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(null as any);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param tenantId (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    tenantId: number | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<UserDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (tenantId === null)
      throw new Error("The parameter 'tenantId' cannot be null.");
    else if (tenantId !== undefined)
      url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<UserDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<UserDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UserDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDtoPagedResultDto>(null as any);
  }
}

export class ApplicationInfoDto implements IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data["version"];
      this.releaseDate = _data["releaseDate"]
        ? moment(_data["releaseDate"].toString())
        : <any>undefined;
      if (_data["features"]) {
        this.features = {} as any;
        for (let key in _data["features"]) {
          if (_data["features"].hasOwnProperty(key))
            (<any>this.features)[key] = _data["features"][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["version"] = this.version;
    data["releaseDate"] = this.releaseDate
      ? this.releaseDate.toISOString()
      : <any>undefined;
    if (this.features) {
      data["features"] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key))
          (<any>data["features"])[key] = (<any>this.features)[key];
      }
    }
    return data;
  }

  clone(): ApplicationInfoDto {
    const json = this.toJSON();
    let result = new ApplicationInfoDto();
    result.init(json);
    return result;
  }
}

export interface IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
      this.password = _data["password"];
      this.rememberClient = _data["rememberClient"];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
    data["password"] = this.password;
    data["rememberClient"] = this.rememberClient;
    return data;
  }

  clone(): AuthenticateModel {
    const json = this.toJSON();
    let result = new AuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;
  isHostSideUser: boolean;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.userId = _data["userId"];
      this.isHostSideUser = _data["isHostSideUser"];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["userId"] = this.userId;
    data["isHostSideUser"] = this.isHostSideUser;
    return data;
  }

  clone(): AuthenticateResultModel {
    const json = this.toJSON();
    let result = new AuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;
  isHostSideUser: boolean;
}

export class BrandDto implements IBrandDto {
  id: number;
  name: string | undefined;
  logo: string | undefined;

  constructor(data?: IBrandDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.logo = _data["logo"];
    }
  }

  static fromJS(data: any): BrandDto {
    data = typeof data === "object" ? data : {};
    let result = new BrandDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["logo"] = this.logo;
    return data;
  }

  clone(): BrandDto {
    const json = this.toJSON();
    let result = new BrandDto();
    result.init(json);
    return result;
  }
}

export interface IBrandDto {
  id: number;
  name: string | undefined;
  logo: string | undefined;
}

export class BrandDtoListResultDto implements IBrandDtoListResultDto {
  items: BrandDto[] | undefined;

  constructor(data?: IBrandDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(BrandDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BrandDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BrandDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): BrandDtoListResultDto {
    const json = this.toJSON();
    let result = new BrandDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IBrandDtoListResultDto {
  items: BrandDto[] | undefined;
}

export class BrandDtoPagedResultDto implements IBrandDtoPagedResultDto {
  items: BrandDto[] | undefined;
  totalCount: number;

  constructor(data?: IBrandDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(BrandDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BrandDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BrandDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BrandDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BrandDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBrandDtoPagedResultDto {
  items: BrandDto[] | undefined;
  totalCount: number;
}

export class BrandingDto implements IBrandingDto {
  id: number;
  hotelName: string;
  phoneNumber: string;
  hotelAddress: string;
  hotelDescription: string | undefined;
  image: string | undefined;

  constructor(data?: IBrandingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.hotelName = _data["hotelName"];
      this.phoneNumber = _data["phoneNumber"];
      this.hotelAddress = _data["hotelAddress"];
      this.hotelDescription = _data["hotelDescription"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): BrandingDto {
    data = typeof data === "object" ? data : {};
    let result = new BrandingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["hotelName"] = this.hotelName;
    data["phoneNumber"] = this.phoneNumber;
    data["hotelAddress"] = this.hotelAddress;
    data["hotelDescription"] = this.hotelDescription;
    data["image"] = this.image;
    return data;
  }

  clone(): BrandingDto {
    const json = this.toJSON();
    let result = new BrandingDto();
    result.init(json);
    return result;
  }
}

export interface IBrandingDto {
  id: number;
  hotelName: string;
  phoneNumber: string;
  hotelAddress: string;
  hotelDescription: string | undefined;
  image: string | undefined;
}

export class BrandingDtoListResultDto implements IBrandingDtoListResultDto {
  items: BrandingDto[] | undefined;

  constructor(data?: IBrandingDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BrandingDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BrandingDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BrandingDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): BrandingDtoListResultDto {
    const json = this.toJSON();
    let result = new BrandingDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IBrandingDtoListResultDto {
  items: BrandingDto[] | undefined;
}

export class BrandingDtoPagedResultDto implements IBrandingDtoPagedResultDto {
  items: BrandingDto[] | undefined;
  totalCount: number;

  constructor(data?: IBrandingDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BrandingDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BrandingDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BrandingDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BrandingDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BrandingDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBrandingDtoPagedResultDto {
  items: BrandingDto[] | undefined;
  totalCount: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
  currentPassword: string;
  newPassword: string;

  constructor(data?: IChangePasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data["currentPassword"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangePasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currentPassword"] = this.currentPassword;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ChangePasswordDto {
    const json = this.toJSON();
    let result = new ChangePasswordDto();
    result.init(json);
    return result;
  }
}

export interface IChangePasswordDto {
  currentPassword: string;
  newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
  theme: string;

  constructor(data?: IChangeUiThemeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.theme = _data["theme"];
    }
  }

  static fromJS(data: any): ChangeUiThemeInput {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUiThemeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["theme"] = this.theme;
    return data;
  }

  clone(): ChangeUiThemeInput {
    const json = this.toJSON();
    let result = new ChangeUiThemeInput();
    result.init(json);
    return result;
  }
}

export interface IChangeUiThemeInput {
  theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName: string;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data["languageName"];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageName"] = this.languageName;
    return data;
  }

  clone(): ChangeUserLanguageDto {
    const json = this.toJSON();
    let result = new ChangeUserLanguageDto();
    result.init(json);
    return result;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string;
}

export class CreateBrandDto implements ICreateBrandDto {
  name: string | undefined;
  logo: string | undefined;

  constructor(data?: ICreateBrandDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.logo = _data["logo"];
    }
  }

  static fromJS(data: any): CreateBrandDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateBrandDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["logo"] = this.logo;
    return data;
  }

  clone(): CreateBrandDto {
    const json = this.toJSON();
    let result = new CreateBrandDto();
    result.init(json);
    return result;
  }
}

export interface ICreateBrandDto {
  name: string | undefined;
  logo: string | undefined;
}

export class CreateBrandingDto implements ICreateBrandingDto {
  hotelName: string;
  phoneNumber: string;
  hotelAddress: string;
  hotelDescription: string | undefined;
  image: string | undefined;

  constructor(data?: ICreateBrandingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hotelName = _data["hotelName"];
      this.phoneNumber = _data["phoneNumber"];
      this.hotelAddress = _data["hotelAddress"];
      this.hotelDescription = _data["hotelDescription"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): CreateBrandingDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateBrandingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["hotelName"] = this.hotelName;
    data["phoneNumber"] = this.phoneNumber;
    data["hotelAddress"] = this.hotelAddress;
    data["hotelDescription"] = this.hotelDescription;
    data["image"] = this.image;
    return data;
  }

  clone(): CreateBrandingDto {
    const json = this.toJSON();
    let result = new CreateBrandingDto();
    result.init(json);
    return result;
  }
}

export interface ICreateBrandingDto {
  hotelName: string;
  phoneNumber: string;
  hotelAddress: string;
  hotelDescription: string | undefined;
  image: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
  name: string;
  displayName: string;

  constructor(data?: ICreateEditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
    }
  }

  static fromJS(data: any): CreateEditionDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateEditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    return data;
  }

  clone(): CreateEditionDto {
    const json = this.toJSON();
    let result = new CreateEditionDto();
    result.init(json);
    return result;
  }
}

export interface ICreateEditionDto {
  name: string;
  displayName: string;
}

export class CreateRequestDto implements ICreateRequestDto {
  roomNumber: number;
  roomName: string;
  categoryName: string;
  price: number;

  constructor(data?: ICreateRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roomNumber = _data["roomNumber"];
      this.roomName = _data["roomName"];
      this.categoryName = _data["categoryName"];
      this.price = _data["price"];
    }
  }

  static fromJS(data: any): CreateRequestDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roomNumber"] = this.roomNumber;
    data["roomName"] = this.roomName;
    data["categoryName"] = this.categoryName;
    data["price"] = this.price;
    return data;
  }

  clone(): CreateRequestDto {
    const json = this.toJSON();
    let result = new CreateRequestDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRequestDto {
  roomNumber: number;
  roomName: string;
  categoryName: string;
  price: number;
}

export class CreateRoleDto implements ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: ICreateRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): CreateRoleDto {
    const json = this.toJSON();
    let result = new CreateRoleDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class CreateRoomDto implements ICreateRoomDto {
  roomNumber: number;
  roomName: string;
  categoryName: string;
  price: number;
  image: string | undefined;

  constructor(data?: ICreateRoomDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roomNumber = _data["roomNumber"];
      this.roomName = _data["roomName"];
      this.categoryName = _data["categoryName"];
      this.price = _data["price"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): CreateRoomDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoomDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roomNumber"] = this.roomNumber;
    data["roomName"] = this.roomName;
    data["categoryName"] = this.categoryName;
    data["price"] = this.price;
    data["image"] = this.image;
    return data;
  }

  clone(): CreateRoomDto {
    const json = this.toJSON();
    let result = new CreateRoomDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoomDto {
  roomNumber: number;
  roomName: string;
  categoryName: string;
  price: number;
  image: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;

  constructor(data?: ICreateTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.adminEmailAddress = _data["adminEmailAddress"];
      this.connectionString = _data["connectionString"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CreateTenantDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["adminEmailAddress"] = this.adminEmailAddress;
    data["connectionString"] = this.connectionString;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): CreateTenantDto {
    const json = this.toJSON();
    let result = new CreateTenantDto();
    result.init(json);
    return result;
  }
}

export interface ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    data["password"] = this.password;
    return data;
  }

  clone(): CreateUserDto {
    const json = this.toJSON();
    let result = new CreateUserDto();
    result.init(json);
    return result;
  }
}

export interface ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;
}

export class EditionDto implements IEditionDto {
  id: number;
  name: string;
  displayName: string;

  constructor(data?: IEditionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
    }
  }

  static fromJS(data: any): EditionDto {
    data = typeof data === "object" ? data : {};
    let result = new EditionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    return data;
  }

  clone(): EditionDto {
    const json = this.toJSON();
    let result = new EditionDto();
    result.init(json);
    return result;
  }
}

export interface IEditionDto {
  id: number;
  name: string;
  displayName: string;
}

export class EditionDtoPagedResultDto implements IEditionDtoPagedResultDto {
  items: EditionDto[] | undefined;
  totalCount: number;

  constructor(data?: IEditionDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(EditionDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): EditionDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new EditionDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): EditionDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EditionDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEditionDtoPagedResultDto {
  items: EditionDto[] | undefined;
  totalCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authProvider = _data["authProvider"];
      this.providerKey = _data["providerKey"];
      this.providerAccessCode = _data["providerAccessCode"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["authProvider"] = this.authProvider;
    data["providerKey"] = this.providerKey;
    data["providerAccessCode"] = this.providerAccessCode;
    return data;
  }

  clone(): ExternalAuthenticateModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;
}

export class ExternalAuthenticateResultModel
  implements IExternalAuthenticateResultModel
{
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.waitingForActivation = _data["waitingForActivation"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["waitingForActivation"] = this.waitingForActivation;
    return data;
  }

  clone(): ExternalAuthenticateResultModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel
  implements IExternalLoginProviderInfoModel
{
  name: string | undefined;
  clientId: string | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.clientId = _data["clientId"];
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["clientId"] = this.clientId;
    return data;
  }

  clone(): ExternalLoginProviderInfoModel {
    const json = this.toJSON();
    let result = new ExternalLoginProviderInfoModel();
    result.init(json);
    return result;
  }
}

export interface IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): FlatPermissionDto {
    const json = this.toJSON();
    let result = new FlatPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class GetCurrentLoginInformationsOutput
  implements IGetCurrentLoginInformationsOutput
{
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.application = _data["application"]
        ? ApplicationInfoDto.fromJS(_data["application"])
        : <any>undefined;
      this.user = _data["user"]
        ? UserLoginInfoDto.fromJS(_data["user"])
        : <any>undefined;
      this.tenant = _data["tenant"]
        ? TenantLoginInfoDto.fromJS(_data["tenant"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["application"] = this.application
      ? this.application.toJSON()
      : <any>undefined;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    return data;
  }

  clone(): GetCurrentLoginInformationsOutput {
    const json = this.toJSON();
    let result = new GetCurrentLoginInformationsOutput();
    result.init(json);
    return result;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;
}

export class GetPermissionsOutputDto implements IGetPermissionsOutputDto {
  name: string | undefined;
  displayName: string | undefined;

  constructor(data?: IGetPermissionsOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
    }
  }

  static fromJS(data: any): GetPermissionsOutputDto {
    data = typeof data === "object" ? data : {};
    let result = new GetPermissionsOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    return data;
  }

  clone(): GetPermissionsOutputDto {
    const json = this.toJSON();
    let result = new GetPermissionsOutputDto();
    result.init(json);
    return result;
  }
}

export interface IGetPermissionsOutputDto {
  name: string | undefined;
  displayName: string | undefined;
}

export class GetPermissionsOutputDtoListResultDto
  implements IGetPermissionsOutputDtoListResultDto
{
  items: GetPermissionsOutputDto[] | undefined;

  constructor(data?: IGetPermissionsOutputDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(GetPermissionsOutputDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetPermissionsOutputDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new GetPermissionsOutputDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): GetPermissionsOutputDtoListResultDto {
    const json = this.toJSON();
    let result = new GetPermissionsOutputDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IGetPermissionsOutputDtoListResultDto {
  items: GetPermissionsOutputDto[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data["role"]
        ? RoleEditDto.fromJS(_data["role"])
        : <any>undefined;
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data["grantedPermissionNames"])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data["grantedPermissionNames"])
          this.grantedPermissionNames.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["role"] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data["grantedPermissionNames"] = [];
      for (let item of this.grantedPermissionNames)
        data["grantedPermissionNames"].push(item);
    }
    return data;
  }

  clone(): GetRoleForEditOutput {
    const json = this.toJSON();
    let result = new GetRoleForEditOutput();
    result.init(json);
    return result;
  }
}

export interface IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class GetUserPermissionsOutputDto
  implements IGetUserPermissionsOutputDto
{
  name: string | undefined;
  displayName: string | undefined;

  constructor(data?: IGetUserPermissionsOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
    }
  }

  static fromJS(data: any): GetUserPermissionsOutputDto {
    data = typeof data === "object" ? data : {};
    let result = new GetUserPermissionsOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    return data;
  }

  clone(): GetUserPermissionsOutputDto {
    const json = this.toJSON();
    let result = new GetUserPermissionsOutputDto();
    result.init(json);
    return result;
  }
}

export interface IGetUserPermissionsOutputDto {
  name: string | undefined;
  displayName: string | undefined;
}

export class GetUserPermissionsOutputDtoListResultDto
  implements IGetUserPermissionsOutputDtoListResultDto
{
  items: GetUserPermissionsOutputDto[] | undefined;

  constructor(data?: IGetUserPermissionsOutputDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(GetUserPermissionsOutputDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetUserPermissionsOutputDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new GetUserPermissionsOutputDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): GetUserPermissionsOutputDtoListResultDto {
    const json = this.toJSON();
    let result = new GetUserPermissionsOutputDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IGetUserPermissionsOutputDtoListResultDto {
  items: GetUserPermissionsOutputDto[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
  id: number;

  constructor(data?: IInt64EntityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Int64EntityDto {
    data = typeof data === "object" ? data : {};
    let result = new Int64EntityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }

  clone(): Int64EntityDto {
    const json = this.toJSON();
    let result = new Int64EntityDto();
    result.init(json);
    return result;
  }
}

export interface IInt64EntityDto {
  id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName: string;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    return data;
  }

  clone(): IsTenantAvailableInput {
    const json = this.toJSON();
    let result = new IsTenantAvailableInput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data["state"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["state"] = this.state;
    data["tenantId"] = this.tenantId;
    return data;
  }

  clone(): IsTenantAvailableOutput {
    const json = this.toJSON();
    let result = new IsTenantAvailableOutput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;
}

export enum MultiTenancySides {
  _1 = 1,
  _2 = 2,
}

export class NameValue implements INameValue {
  name: string | undefined;
  value: string | undefined;

  constructor(data?: INameValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): NameValue {
    data = typeof data === "object" ? data : {};
    let result = new NameValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["value"] = this.value;
    return data;
  }

  clone(): NameValue {
    const json = this.toJSON();
    let result = new NameValue();
    result.init(json);
    return result;
  }
}

export interface INameValue {
  name: string | undefined;
  value: string | undefined;
}

export class PagedAuditLogResultResponseDto
  implements IPagedAuditLogResultResponseDto
{
  id: number;
  browserInfo: string | undefined;
  clientIpAddress: string | undefined;
  clientName: string | undefined;
  methodName: string | undefined;
  serviceName: string | undefined;
  exception: string | undefined;
  exceptionMessage: string | undefined;

  constructor(data?: IPagedAuditLogResultResponseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.browserInfo = _data["browserInfo"];
      this.clientIpAddress = _data["clientIpAddress"];
      this.clientName = _data["clientName"];
      this.methodName = _data["methodName"];
      this.serviceName = _data["serviceName"];
      this.exception = _data["exception"];
      this.exceptionMessage = _data["exceptionMessage"];
    }
  }

  static fromJS(data: any): PagedAuditLogResultResponseDto {
    data = typeof data === "object" ? data : {};
    let result = new PagedAuditLogResultResponseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["browserInfo"] = this.browserInfo;
    data["clientIpAddress"] = this.clientIpAddress;
    data["clientName"] = this.clientName;
    data["methodName"] = this.methodName;
    data["serviceName"] = this.serviceName;
    data["exception"] = this.exception;
    data["exceptionMessage"] = this.exceptionMessage;
    return data;
  }

  clone(): PagedAuditLogResultResponseDto {
    const json = this.toJSON();
    let result = new PagedAuditLogResultResponseDto();
    result.init(json);
    return result;
  }
}

export interface IPagedAuditLogResultResponseDto {
  id: number;
  browserInfo: string | undefined;
  clientIpAddress: string | undefined;
  clientName: string | undefined;
  methodName: string | undefined;
  serviceName: string | undefined;
  exception: string | undefined;
  exceptionMessage: string | undefined;
}

export class PagedAuditLogResultResponseDtoPagedResultDto
  implements IPagedAuditLogResultResponseDtoPagedResultDto
{
  items: PagedAuditLogResultResponseDto[] | undefined;
  totalCount: number;

  constructor(data?: IPagedAuditLogResultResponseDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PagedAuditLogResultResponseDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): PagedAuditLogResultResponseDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PagedAuditLogResultResponseDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): PagedAuditLogResultResponseDtoPagedResultDto {
    const json = this.toJSON();
    let result = new PagedAuditLogResultResponseDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IPagedAuditLogResultResponseDtoPagedResultDto {
  items: PagedAuditLogResultResponseDto[] | undefined;
  totalCount: number;
}

export class PagedTenantResultDto implements IPagedTenantResultDto {
  id: number;
  name: string | undefined;
  tenancyName: string | undefined;
  editionId: number | undefined;
  editionName: string | undefined;

  constructor(data?: IPagedTenantResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.tenancyName = _data["tenancyName"];
      this.editionId = _data["editionId"];
      this.editionName = _data["editionName"];
    }
  }

  static fromJS(data: any): PagedTenantResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PagedTenantResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["tenancyName"] = this.tenancyName;
    data["editionId"] = this.editionId;
    data["editionName"] = this.editionName;
    return data;
  }

  clone(): PagedTenantResultDto {
    const json = this.toJSON();
    let result = new PagedTenantResultDto();
    result.init(json);
    return result;
  }
}

export interface IPagedTenantResultDto {
  id: number;
  name: string | undefined;
  tenancyName: string | undefined;
  editionId: number | undefined;
  editionName: string | undefined;
}

export class PagedTenantResultDtoPagedResultDto
  implements IPagedTenantResultDtoPagedResultDto
{
  items: PagedTenantResultDto[] | undefined;
  totalCount: number;

  constructor(data?: IPagedTenantResultDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PagedTenantResultDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): PagedTenantResultDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PagedTenantResultDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): PagedTenantResultDtoPagedResultDto {
    const json = this.toJSON();
    let result = new PagedTenantResultDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IPagedTenantResultDtoPagedResultDto {
  items: PagedTenantResultDto[] | undefined;
  totalCount: number;
}

export class PermissionDto implements IPermissionDto {
  id: number;
  parent: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.parent = _data["parent"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["parent"] = this.parent;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): PermissionDto {
    const json = this.toJSON();
    let result = new PermissionDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDto {
  id: number;
  parent: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;

  constructor(data?: IPermissionDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PermissionDtoListResultDto {
    const json = this.toJSON();
    let result = new PermissionDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;
}

export class RegisterInput implements IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;

  constructor(data?: IRegisterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
      this.password = _data["password"];
      this.captchaResponse = _data["captchaResponse"];
    }
  }

  static fromJS(data: any): RegisterInput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    data["password"] = this.password;
    data["captchaResponse"] = this.captchaResponse;
    return data;
  }

  clone(): RegisterInput {
    const json = this.toJSON();
    let result = new RegisterInput();
    result.init(json);
    return result;
  }
}

export interface IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin: boolean;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data["canLogin"];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canLogin"] = this.canLogin;
    return data;
  }

  clone(): RegisterOutput {
    const json = this.toJSON();
    let result = new RegisterOutput();
    result.init(json);
    return result;
  }
}

export interface IRegisterOutput {
  canLogin: boolean;
}

export class RequestDto implements IRequestDto {
  id: number;
  roomName: string;
  roomNumber: number;
  categoryName: string;
  price: number;

  constructor(data?: IRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.roomName = _data["roomName"];
      this.roomNumber = _data["roomNumber"];
      this.categoryName = _data["categoryName"];
      this.price = _data["price"];
    }
  }

  static fromJS(data: any): RequestDto {
    data = typeof data === "object" ? data : {};
    let result = new RequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["roomName"] = this.roomName;
    data["roomNumber"] = this.roomNumber;
    data["categoryName"] = this.categoryName;
    data["price"] = this.price;
    return data;
  }

  clone(): RequestDto {
    const json = this.toJSON();
    let result = new RequestDto();
    result.init(json);
    return result;
  }
}

export interface IRequestDto {
  id: number;
  roomName: string;
  roomNumber: number;
  categoryName: string;
  price: number;
}

export class RequestDtoListResultDto implements IRequestDtoListResultDto {
  items: RequestDto[] | undefined;

  constructor(data?: IRequestDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RequestDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RequestDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RequestDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RequestDtoListResultDto {
    const json = this.toJSON();
    let result = new RequestDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRequestDtoListResultDto {
  items: RequestDto[] | undefined;
}

export class RequestDtoPagedResultDto implements IRequestDtoPagedResultDto {
  items: RequestDto[] | undefined;
  totalCount: number;

  constructor(data?: IRequestDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RequestDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RequestDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RequestDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RequestDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RequestDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRequestDtoPagedResultDto {
  items: RequestDto[] | undefined;
  totalCount: number;
}

export class ResetPasswordDto implements IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;

  constructor(data?: IResetPasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.adminPassword = _data["adminPassword"];
      this.userId = _data["userId"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ResetPasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ResetPasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["adminPassword"] = this.adminPassword;
    data["userId"] = this.userId;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ResetPasswordDto {
    const json = this.toJSON();
    let result = new ResetPasswordDto();
    result.init(json);
    return result;
  }
}

export interface IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;
}

export class ResetPasswordInputDto implements IResetPasswordInputDto {
  email: string;

  constructor(data?: IResetPasswordInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ResetPasswordInputDto {
    data = typeof data === "object" ? data : {};
    let result = new ResetPasswordInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    return data;
  }

  clone(): ResetPasswordInputDto {
    const json = this.toJSON();
    let result = new ResetPasswordInputDto();
    result.init(json);
    return result;
  }
}

export interface IResetPasswordInputDto {
  email: string;
}

export class RoleDto implements IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): RoleDto {
    const json = this.toJSON();
    let result = new RoleDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
  items: RoleDto[] | undefined;

  constructor(data?: IRoleDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoListResultDto {
  items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;

  constructor(data?: IRoleDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RoleDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RoleDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RoleDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
      this.isStatic = _data["isStatic"];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    return data;
  }

  clone(): RoleEditDto {
    const json = this.toJSON();
    let result = new RoleEditDto();
    result.init(json);
    return result;
  }
}

export interface IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;

  constructor(data?: IRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.isStatic = _data["isStatic"];
      this.isDefault = _data["isDefault"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): RoleListDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["isStatic"] = this.isStatic;
    data["isDefault"] = this.isDefault;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): RoleListDto {
    const json = this.toJSON();
    let result = new RoleListDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;

  constructor(data?: IRoleListDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleListDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleListDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleListDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;
}

export class RoomDto implements IRoomDto {
  id: number;
  roomName: string;
  roomNumber: number;
  categoryName: string;
  price: number;
  image: string | undefined;

  constructor(data?: IRoomDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.roomName = _data["roomName"];
      this.roomNumber = _data["roomNumber"];
      this.categoryName = _data["categoryName"];
      this.price = _data["price"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): RoomDto {
    data = typeof data === "object" ? data : {};
    let result = new RoomDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["roomName"] = this.roomName;
    data["roomNumber"] = this.roomNumber;
    data["categoryName"] = this.categoryName;
    data["price"] = this.price;
    data["image"] = this.image;
    return data;
  }

  clone(): RoomDto {
    const json = this.toJSON();
    let result = new RoomDto();
    result.init(json);
    return result;
  }
}

export interface IRoomDto {
  id: number;
  roomName: string;
  roomNumber: number;
  categoryName: string;
  price: number;
  image: string | undefined;
}

export class RoomDtoListResultDto implements IRoomDtoListResultDto {
  items: RoomDto[] | undefined;

  constructor(data?: IRoomDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoomDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoomDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoomDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoomDtoListResultDto {
    const json = this.toJSON();
    let result = new RoomDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoomDtoListResultDto {
  items: RoomDto[] | undefined;
}

export class RoomDtoPagedResultDto implements IRoomDtoPagedResultDto {
  items: RoomDto[] | undefined;
  totalCount: number;

  constructor(data?: IRoomDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoomDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RoomDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoomDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RoomDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RoomDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoomDtoPagedResultDto {
  items: RoomDto[] | undefined;
  totalCount: number;
}

export class SetFeatureDto implements ISetFeatureDto {
  editionId: number;
  features: NameValue[] | undefined;

  constructor(data?: ISetFeatureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.editionId = _data["editionId"];
      if (Array.isArray(_data["features"])) {
        this.features = [] as any;
        for (let item of _data["features"])
          this.features.push(NameValue.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SetFeatureDto {
    data = typeof data === "object" ? data : {};
    let result = new SetFeatureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["editionId"] = this.editionId;
    if (Array.isArray(this.features)) {
      data["features"] = [];
      for (let item of this.features) data["features"].push(item.toJSON());
    }
    return data;
  }

  clone(): SetFeatureDto {
    const json = this.toJSON();
    let result = new SetFeatureDto();
    result.init(json);
    return result;
  }
}

export interface ISetFeatureDto {
  editionId: number;
  features: NameValue[] | undefined;
}

export class SetPermissionsInputDto implements ISetPermissionsInputDto {
  roleId: number;
  permissions: string[] | undefined;

  constructor(data?: ISetPermissionsInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data["roleId"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions.push(item);
      }
    }
  }

  static fromJS(data: any): SetPermissionsInputDto {
    data = typeof data === "object" ? data : {};
    let result = new SetPermissionsInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roleId"] = this.roleId;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    return data;
  }

  clone(): SetPermissionsInputDto {
    const json = this.toJSON();
    let result = new SetPermissionsInputDto();
    result.init(json);
    return result;
  }
}

export interface ISetPermissionsInputDto {
  roleId: number;
  permissions: string[] | undefined;
}

export class SetTenantFeatureDto implements ISetTenantFeatureDto {
  tenantId: number;
  features: NameValue[] | undefined;

  constructor(data?: ISetTenantFeatureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data["tenantId"];
      if (Array.isArray(_data["features"])) {
        this.features = [] as any;
        for (let item of _data["features"])
          this.features.push(NameValue.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SetTenantFeatureDto {
    data = typeof data === "object" ? data : {};
    let result = new SetTenantFeatureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenantId"] = this.tenantId;
    if (Array.isArray(this.features)) {
      data["features"] = [];
      for (let item of this.features) data["features"].push(item.toJSON());
    }
    return data;
  }

  clone(): SetTenantFeatureDto {
    const json = this.toJSON();
    let result = new SetTenantFeatureDto();
    result.init(json);
    return result;
  }
}

export interface ISetTenantFeatureDto {
  tenantId: number;
  features: NameValue[] | undefined;
}

export class SetUserPermissionsInputDto implements ISetUserPermissionsInputDto {
  tenantId: number | undefined;
  userId: string | undefined;
  permissions: string[] | undefined;

  constructor(data?: ISetUserPermissionsInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data["tenantId"];
      this.userId = _data["userId"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"]) this.permissions.push(item);
      }
    }
  }

  static fromJS(data: any): SetUserPermissionsInputDto {
    data = typeof data === "object" ? data : {};
    let result = new SetUserPermissionsInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenantId"] = this.tenantId;
    data["userId"] = this.userId;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions) data["permissions"].push(item);
    }
    return data;
  }

  clone(): SetUserPermissionsInputDto {
    const json = this.toJSON();
    let result = new SetUserPermissionsInputDto();
    result.init(json);
    return result;
  }
}

export interface ISetUserPermissionsInputDto {
  tenantId: number | undefined;
  userId: string | undefined;
  permissions: string[] | undefined;
}

export enum TenantAvailabilityState {
  _1 = 1,
  _2 = 2,
  _3 = 3,
}

export class TenantDto implements ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): TenantDto {
    const json = this.toJSON();
    let result = new TenantDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;

  constructor(data?: ITenantDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(TenantDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): TenantDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): TenantDtoPagedResultDto {
    const json = this.toJSON();
    let result = new TenantDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    return data;
  }

  clone(): TenantLoginInfoDto {
    const json = this.toJSON();
    let result = new TenantLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;
}

export class UpdatePasswordInputDto implements IUpdatePasswordInputDto {
  userEmail: string | undefined;
  token: string | undefined;
  newPassword: string | undefined;

  constructor(data?: IUpdatePasswordInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userEmail = _data["userEmail"];
      this.token = _data["token"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): UpdatePasswordInputDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePasswordInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userEmail"] = this.userEmail;
    data["token"] = this.token;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): UpdatePasswordInputDto {
    const json = this.toJSON();
    let result = new UpdatePasswordInputDto();
    result.init(json);
    return result;
  }
}

export interface IUpdatePasswordInputDto {
  userEmail: string | undefined;
  token: string | undefined;
  newPassword: string | undefined;
}

export class UploadImageOutputModel implements IUploadImageOutputModel {
  url: string | undefined;

  constructor(data?: IUploadImageOutputModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.url = _data["url"];
    }
  }

  static fromJS(data: any): UploadImageOutputModel {
    data = typeof data === "object" ? data : {};
    let result = new UploadImageOutputModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["url"] = this.url;
    return data;
  }

  clone(): UploadImageOutputModel {
    const json = this.toJSON();
    let result = new UploadImageOutputModel();
    result.init(json);
    return result;
  }
}

export interface IUploadImageOutputModel {
  url: string | undefined;
}

export class UserDto implements IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      this.fullName = _data["fullName"];
      this.lastLoginTime = _data["lastLoginTime"]
        ? moment(_data["lastLoginTime"].toString())
        : <any>undefined;
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    data["fullName"] = this.fullName;
    data["lastLoginTime"] = this.lastLoginTime
      ? this.lastLoginTime.toISOString()
      : <any>undefined;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    return data;
  }

  clone(): UserDto {
    const json = this.toJSON();
    let result = new UserDto();
    result.init(json);
    return result;
  }
}

export interface IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;
}

export class UserDtoListResultDto implements IUserDtoListResultDto {
  items: UserDto[] | undefined;

  constructor(data?: IUserDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(UserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): UserDtoListResultDto {
    const json = this.toJSON();
    let result = new UserDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserDtoListResultDto {
  items: UserDto[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;

  constructor(data?: IUserDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(UserDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): UserDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): UserDtoPagedResultDto {
    const json = this.toJSON();
    let result = new UserDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    return data;
  }

  clone(): UserLoginInfoDto {
    const json = this.toJSON();
    let result = new UserLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
}

export class UserPermissionDto implements IUserPermissionDto {
  id: number;
  parent: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IUserPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.parent = _data["parent"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): UserPermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new UserPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["parent"] = this.parent;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): UserPermissionDto {
    const json = this.toJSON();
    let result = new UserPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IUserPermissionDto {
  id: number;
  parent: string | undefined;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class UserPermissionDtoListResultDto
  implements IUserPermissionDtoListResultDto
{
  items: UserPermissionDto[] | undefined;

  constructor(data?: IUserPermissionDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(UserPermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserPermissionDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new UserPermissionDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): UserPermissionDtoListResultDto {
    const json = this.toJSON();
    let result = new UserPermissionDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserPermissionDtoListResultDto {
  items: UserPermissionDto[] | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
